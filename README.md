# autofinder
Test of algorithm to image only a sample and not surrounding tissue using serial-section 2-photon imaging. 


# Generating pStack files
The command `boundingBoxesFromLastSection.test.runOnStackStruct(pStack)` calculates bounding boxes for 
a whole image stack. 
The input argument `pStack` is a structure which needs to be generated by the user. 
It's a good idea to generate these and store to disk in some reasonable way. 
e.g. Inside sub-directories divided up however makes sense, such as one directory containing all acquisitions of single samples, one with two samples, etc. 
To generate the pStack files do the following


We will work with imaging stacks (`imStack`, below) obtained from the BakingTray preview stacks. 

```
>> nSamples=2;
>> pStack = boundingBoxesFromLastSection.test.stackToGroundTruth(imStack,'/pathTo/recipeFile',nSamples)

pStack = 

  struct with fields:

               imStack: [1138x2826x192 int16]
                recipe: [1x1 struct]
    voxelSizeInMicrons: 8.1855
     tileSizeInMicrons: 1.0281e+03
              nSamples: 2
             binarized: []
               borders: {}

```

There are two empty fields (`binarized` and `borders`) in the `pStack` structure. 
These need to be populated with what we will treat as a proxy for ground truth: which regions actually contain brain.
The is necessary for subsequent evaluation steps but is not necessary to run the automatic tissue-finding code. 
This is done with:

```
pStack=boundingBoxesFromLastSection.test.genGroundTruthBorders(pStack,7)
```

And the results visualised with:
```
>> volView(pStack.imStack,[1,200],pStack.borders)  
```

Correct any issues you see by any means necessary. 

# Generating bounding boxes from a stack structure
```
>> OUT=boundingBoxesFromLastSection.test.runOnStackStruct(pStack)
```

Visualise it:
```
>> b={{OUT.BoundingBoxes},{},{}}
>> volView(pStack.imStack,[1,200],b)
```

# Evaluating results
First ensure you have run analyses on all samples. 
Run the test script on one directory:

```
>> boundingBoxesFromLastSection.test.runOnAllInDir('stacks/singleBrains')
```

You can optionally generate a text file that sumarises the results:
```
>> boundingBoxesFromLastSection.test.evaluateDir('tests/191211_1545')
```

To visualise the outcome of one sample:
```
>> load LIC_003_previewStack.mat 
>> load tests/191211_1545/log_LIC_003_previewStack.mat
>> b={{testLog.BoundingBoxes},{},{}};
>> volView(pStack.imStack,[1,200],b);
```

To run on all directories containing sample data within the stacks sub-directory do:
```
>> boundingBoxesFromLastSection.test.runOnAllInDir
```


## How it works
The general idea is that bounding boxes around sample(s) are found in the current section (`n`), expanded by about 200 microns, then applied to section `n+1`. 
When section `n+1` is imaged, the bounding boxes are re-calculated as before.
This approach takes into account the fact that the imaged area of most samples changes during the acquisition. 
Because the acquisition is tiled and we round up to the nearest tile, we usually end up with a border of more than 200 microns. 
In practice, this avoids clipping the sample in cases where it gets larger quickly as we section through it. 
There is likely no need to search for cases where sample edges are clipped in order to add tiles. 
We image rectangular bounding boxes rather than oddly shaped tile patterns because in most cases our tile size is large. 


### Implementation
`imStack` is a downsampled stack that originates from the preview images of a BakingTray serial section 2p acquisition. 
To calculate the bounding boxes for section 11 we would run:
```
boundingBoxesFromLastSection(imStack(:,:,10))
```

The function will return an image of section 10 with the bounding boxes drawn around it. 
It uses default values for a bunch of important parameters, such as pixel size.
Of course in reality these bounding boxes will need to be evaluated with respect to section 11. 
To perform this exploration we can run the algorithm on the whole stack.
To achieve this we load a "pStack" structure, as produced by `boundingBoxesFromLastSection.test.runOnStackStruct`, above. 
Then, as described above, we can run:
```
 boundingBoxesFromLastSection.test.runOnStackStruct(pStack)
```






## Changelog
v2 Does well with single brains and multiple brains where the individual brains have bounding boxes that are not going to overlap. 
Once bounding boxes overlap we begin to get odd and major failures. 
For instance, whole brains sudenly are excluded. 
An example of this is `threeBrains/AF_C2_2FPPVs_previewStack.mat` with `tThreshSD=4` -- irrespective of threshold we lose the bottom brain from section 17 to section 18. 
The problem lies with `mergeOverlapping`. 
The bounding boxes are correctly found but the merge step produces a bad result when applied to the tile-corrected output.
I believe it is losing a ROI when doing the merge comparisons because it's failing to correctly do comparisons with more than 2 ROIs.

v3 Fixed issues relating to multiple sample ROIs. 
The main problems were that `mergeOverlapping` was deleteing ROIs and that the final bounding-box generation step had a tendency to merge ROIs that should not have been merged. 